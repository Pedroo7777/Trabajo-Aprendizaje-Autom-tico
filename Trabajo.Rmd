---
title: "Trabajo"
author: "Pablo Jacinto Pérez, Pedro Antonio Lozano, Elena Ortega y Juan Giner"
date: "2025-11-25"
output: html_document
---

```{r}
library(dplyr)
library(tidyverse)
library(tidymodels)   # incluye parsnip, recipes, workflows, etc.
library(tidyclust)    # ¡NUEVO! interfaz tidy para clustering
library(cluster)      # para silhouette y agnes/diana
library(factoextra)   # visualizaciones y
library(dendextend)   # dendrogramas 
library(caret)
library(ggplot2)
library(randomForest)
```



```{r}
datos1 <- read_csv("C00028A_2023Q1.csv", locale = readr::locale(encoding = "Latin1"))
datos2 <- read_csv("C00028A_2023Q2.csv", locale = readr::locale(encoding = "Latin1"))
datos3 <- read_csv("C00028A_2023Q3.csv", locale = readr::locale(encoding = "Latin1"))
datos4 <- read_csv("C00028A_2023Q4.csv", locale = readr::locale(encoding = "Latin1"))
datos5 <- read_csv("C00028A_2024Q1.csv", locale = readr::locale(encoding = "Latin1"))
datos6 <- read_csv("C00028A_2024Q2.csv", locale = readr::locale(encoding = "Latin1"))
datos7 <- read_csv("C00028A_2024Q3.csv", locale = readr::locale(encoding = "Latin1"))
datos8 <- read_csv("C00028A_2024Q4.csv", locale = readr::locale(encoding = "Latin1"))
datos9 <- read_csv("C00028A_2025Q1.csv", locale = readr::locale(encoding = "Latin1"))
datos10 <- read_csv("C00028A_2025Q2.csv", locale = readr::locale(encoding = "Latin1"))
datos11 <- read_csv("C00028A_2025Q3.csv", locale = readr::locale(encoding = "Latin1"))

```


```{r}
datos_juntos <- reduce(
  list(datos11, datos10, datos9, datos8, datos7, datos6, datos5, datos4, datos3, datos2, datos1),
  full_join
)


if(!file.exists("data")){
  dir.create("data")
}

write_csv(datos_juntos , "data/datos.csv")

```


## Canal_contratacion, tipo de alojamiento, duración, acompañantes, planificación, Vuelos, alojamiento,                                       comidas, ocio, compras, 

```{r}


datos_filtrados <- datos_juntos %>% select(SEXO, EDAD, NACIONALIDAD, NIVEL_EDUCATIVO, INGRESOS, SITUACION_LABORAL, PROPOSITO, 
                                         CANAL_TOUROPERADOR_AGENCIA_VIAJE, ALOJ_CATEG, NOCHES, COMPANNIA_SOLO, COMPANNIA_PAREJA, 
                                         COMPANNIA_HIJOS, COMPANNIA_OTROS_FAMILIARES, COMPANNIA_AMIGOS, COMPANNIA_COMPANNEROS, 
                                         COMPANNIA_VIAJE_ORGANZ, ANTELACION_VIAJE, COSTE_VUELOS_EUROS, 
                                         COSTE_ALOJ_EUROS, ACTIV_GASTRONOMIA_CANARIA, ACTIV_OCIO, ACTIV_PARQUES_OCIO,
                                         DESGLOSE_OTROS_GASTOS, GASTO_EUROS, CANAL_VISITAS_ANTERIORES, IMPORTANCIA_GASTRONOMIA,
                                         CALIFICAR_EXPERIENCIA, ISLA)
write_csv(datos_filtrados , "data/datos2.csv")


```

```{r}

datos_filtrados <- datos_filtrados %>% mutate(
    PROPOSITO = na_if(PROPOSITO, "_Z")
  )

datos_filtrados <- datos_filtrados %>%
  mutate(
    ISLA = case_when(
      ISLA == "ES708" ~ "Gran Canaria",
      ISLA == "ES709" ~ "Tenerife",
      ISLA == "ES704" ~ "Fuerteventura",
      ISLA == "ES705" ~ "La Palma",
      ISLA == "ES707" ~ "La Gomera",
      ISLA == "ES703" ~ "El Hierro",
      TRUE ~ ISLA
    )
  )

datos_filtrados <- datos_filtrados %>%
  mutate(
    INGRESOS = case_when(
      INGRESOS == "EUR_LT25000" ~ "Menos de 25.000€",
      INGRESOS == "EUR_25000T49999" ~ "25.000€ a 49.999€",
      INGRESOS == "EUR_50000T74999" ~ "50.000€ a 74.999€",
      INGRESOS == "EUR_GE75000" ~ "75.000€ o más",
      INGRESOS == "_Z" ~ "No aplicable",
      TRUE ~ INGRESOS
    )
  )

datos_filtrados <- datos_filtrados %>%
  mutate(
    NIVEL_EDUCATIVO = case_when(
      NIVEL_EDUCATIVO == "_S1" ~ "Primaria o Inferior",
      NIVEL_EDUCATIVO == "EDUC" ~ "Secundaria/FP",
      NIVEL_EDUCATIVO == "_S4" ~ "Estudios Superiores",
      TRUE ~ NIVEL_EDUCATIVO
    )
  )

datos_filtrados <- datos_filtrados %>%
  mutate(
    NACIONALIDAD = case_when(
      NACIONALIDAD == "826" ~ "Reino Unido",
      NACIONALIDAD == "250" ~ "Francia",
      NACIONALIDAD == "276" ~ "Alemania",
      NACIONALIDAD == "724" ~ "España",
      NACIONALIDAD == "756" ~ "Suiza",
      NACIONALIDAD == "528" ~ "Países Bajos",
      NACIONALIDAD == "372" ~ "Irlanda",
      NACIONALIDAD == "203" ~ "República Checa",
      NACIONALIDAD == "616" ~ "Polonia",
      NACIONALIDAD == "703" ~ "Eslovaquia",
      NACIONALIDAD == "724_XES70" ~ "España",
     
      NACIONALIDAD == "_Z" ~ NA_character_, 
      is.na(NACIONALIDAD) ~ NA_character_, 
      
      TRUE ~ "Otro"
    )
  )


datos_filtrados <- datos_filtrados %>%
  mutate(
    SITUACION_LABORAL = case_when(
      SITUACION_LABORAL == "SAL" ~ "Asalariado",
      SITUACION_LABORAL == "SELF" ~ "Trabajador Autónomo (con asalariados)",
      SITUACION_LABORAL == "SELF_NS" ~ "Trabajador Autónomo (sin asalariados)",
      SITUACION_LABORAL == "FAM_HELP" ~ "Familiar que Ayuda",
      
      SITUACION_LABORAL == "RET" ~ "Pensionista",
      SITUACION_LABORAL == "EST" ~ "Estudiante",
      SITUACION_LABORAL == "DES" ~ "Desempleado",
      SITUACION_LABORAL == "H_WIFE" ~ "Tareas del Hogar",
      SITUACION_LABORAL == "OTROS_INACTIVOS" ~ "Inactivo",
      
      SITUACION_LABORAL == "_Z" ~ NA_character_, 
      SITUACION_LABORAL == "_N" ~ NA_character_, 
      is.na(SITUACION_LABORAL) ~ NA_character_,
      
      TRUE ~ "Otro" 
    )
  )

datos_filtrados <- datos_filtrados %>%
  mutate(
    CANAL_TOUROPERADOR_AGENCIA_VIAJE = case_when(
      CANAL_TOUROPERADOR_AGENCIA_VIAJE == 1 ~ "Agencia Física",
      CANAL_TOUROPERADOR_AGENCIA_VIAJE == 2 ~ "Agencia Online",
      CANAL_TOUROPERADOR_AGENCIA_VIAJE == 3 ~ "Directo Alojamiento",
      CANAL_TOUROPERADOR_AGENCIA_VIAJE == 4 ~ "Directo Transporte",
      CANAL_TOUROPERADOR_AGENCIA_VIAJE == 5 ~ "Otro Canal",
      CANAL_TOUROPERADOR_AGENCIA_VIAJE == 6 ~ "Ninguno",
      
      CANAL_TOUROPERADOR_AGENCIA_VIAJE == "_Z" ~ NA_character_, 
      
    )
  )

datos_filtrados <- datos_filtrados %>%
  mutate(
    ALOJAMIENTO = case_when(
      ALOJ_CATEG == "HOTEL_ESTRELLAS_5" ~ "Hotel >=4 Estrellas",
      ALOJ_CATEG == "HOTEL_ESTRELLAS_4" ~ "Hotel >=4 Estrellas",
      ALOJ_CATEG == "HOTEL_ESTRELLAS_3" ~ "Hotel <4 Estrellas",
      ALOJ_CATEG == "HOTEL_ESTRELLAS_2" ~ "Hotel <4 Estrellas", 
      ALOJ_CATEG == "APARTAMENTO_ESTRELLAS_4" ~ "Apartamento 4 Estrellas",
      ALOJ_CATEG == "APARTAMENTO_ESTRELLAS_3" ~ "Otro Apartamento",
      ALOJ_CATEG == "APARTAMENTO_ESTRELLAS_2" ~ "Otro Apartamento",

      ALOJ_CATEG == "APARTAMENTO_DE_VUT" ~ "Otro Apartamento",
      ALOJ_CATEG == "VIVIENDA_GRATUITA" ~ "Vivienda Gratuita",
      ALOJ_CATEG == "PENSION" ~ "Pensión",
      
      ALOJ_CATEG == "_O" ~ "Otro", 
      
      ALOJ_CATEG == "_Z" ~ NA_character_, 
      is.na(ALOJ_CATEG) ~ NA_character_, 
      
      TRUE ~ NA_character_
    )
  )



comp <- c(
  "COMPANNIA_SOLO",
  "COMPANNIA_PAREJA",
  "COMPANNIA_HIJOS",
  "COMPANNIA_OTROS_FAMILIARES",
  "COMPANNIA_AMIGOS",
  "COMPANNIA_COMPANNEROS",
  "COMPANNIA_VIAJE_ORGANZ"
)

datos_filtrados <- datos_filtrados %>%
  mutate(across(
    all_of(comp),
    ~ case_when(
      . == 1 ~ TRUE,
      . == 6 ~ FALSE,
      TRUE   ~ NA
    ),
    .names = "{.col}_TF"
  ))

comp_TF <- paste0(comp, "_TF")

datos_filtrados$compania <- apply(
  datos_filtrados[comp_TF],
  1,
  function(x) {
    if (all(is.na(x))) {
      NA
    } else {
      any(x == TRUE, na.rm = TRUE)
    }
  }
)

datos_filtrados <- datos_filtrados %>%
  mutate(
    antelacion_cat = case_when(
      ANTELACION_VIAJE %in% c("D_LT1", "D1T15", "D16T30") ~ "menos_1_mes",
      ANTELACION_VIAJE %in% c("M1T2")                      ~ "entre_1_3_meses",
      ANTELACION_VIAJE %in% c("M3T6", "M_GT6")             ~ "mas_3_meses",
      ANTELACION_VIAJE %in% c("_Y")                        ~ NA_character_,
      TRUE                                                 ~ NA_character_  
    ),
    antelacion_cat = factor(antelacion_cat,
                            levels = c("menos_1_mes", "entre_1_3_meses", "mas_3_meses"),
                            ordered = TRUE)
  )


datos_filtrados <- datos_filtrados %>%
  mutate(
    across(
      .cols = starts_with("ACTIV_"), 
      .fns = ~ case_when(
        
        . == 1 ~ TRUE,
        . == "1" ~ TRUE, 
        
       
        . == 6 ~ FALSE,
        . == "6" ~ FALSE,
        
       
        . == "_Z" ~ NA,
        . == "_N" ~ NA,
        is.na(.) ~ NA,

        TRUE ~ NA
      )
    )
  )

datos_filtrados <- datos_filtrados %>%
  mutate(
    Visitas_anteriores= case_when(
      CANAL_VISITAS_ANTERIORES == 1 ~ TRUE,
      CANAL_VISITAS_ANTERIORES == "1" ~ TRUE, 
  
      CANAL_VISITAS_ANTERIORES == 6 ~ FALSE,
      CANAL_VISITAS_ANTERIORES == "6" ~ FALSE,
      
      CANAL_VISITAS_ANTERIORES == "_Z" ~ NA,
      CANAL_VISITAS_ANTERIORES == "_N" ~ NA,
      is.na(CANAL_VISITAS_ANTERIORES) ~ NA,
      
      # Cualquier otro valor no mapeado se convierte a NA
      TRUE ~ NA
    )
  )

datos_filtrados <- datos_filtrados %>%
  mutate(
    experiencia_agrupada = case_when(
      CALIFICAR_EXPERIENCIA == "MUCHO_MEJOR" ~ "Buena/Muy Buena", 
      CALIFICAR_EXPERIENCIA == "MEJOR" ~ "Buena/Muy Buena", 
      
      CALIFICAR_EXPERIENCIA == "IGUAL" ~ "Resto",
      CALIFICAR_EXPERIENCIA == "PEOR" ~ "Resto",
      CALIFICAR_EXPERIENCIA == "MUCHO_PEOR" ~ "Resto",
      
      CALIFICAR_EXPERIENCIA == "_Z" ~ NA_character_, 
      is.na(CALIFICAR_EXPERIENCIA) ~ NA_character_,
      
      TRUE ~ NA_character_
    )
  )

```





```{r}
datos_finales <- datos_filtrados %>%
  select(
    everything(),-starts_with("COMPANNIA_"), -ANTELACION_VIAJE, -CANAL_VISITAS_ANTERIORES
  )
```


```{r}
# ==============================================================================
# Árbol de decisión para predecir experiencia_agrupada + ROC y AUC
# ==============================================================================

# 0) Paquetes ------------------------------------------------------------------

library(tidymodels)
library(rpart.plot)
library(janitor)
library(readr)
library(dplyr)
library(rlang)    

set.seed(20251201)

# 1) Carga y preparación básica de datos --------------------------------------


datos <- read_csv("datos_finales.csv", show_col_types = FALSE) |>
  clean_names()

# Conversión de tipos:
# - experiencia_agrupada como factor (target)
# - lógicas a factor (para que el árbol las trate como categóricas)
# - eliminamos calificar_experiencia para evitar "fuga de información"
datos <- datos |>
  mutate(
    experiencia_agrupada = factor(experiencia_agrupada),
    across(where(is.logical), as.factor)
  ) |>
  select(-calificar_experiencia)  

cat("Dimensiones del dataset:", nrow(datos), "filas y", ncol(datos), "columnas\n\n")

cat("Distribución de la variable objetivo experiencia_agrupada:\n")
print(
  datos |>
    count(experiencia_agrupada) |>
    mutate(prop = round(n / sum(n), 3))
)

# 2) División train / test -----------------------------------------------------

set.seed(123)
split_datos <- initial_split(datos, prop = 0.7, strata = experiencia_agrupada)
datos_train <- training(split_datos)
datos_test  <- testing(split_datos)

cat("\nFilas en train:", nrow(datos_train), "\n")
cat("Filas en test :", nrow(datos_test), "\n\n")

# 3) Receta: muy sencilla (sin dummies ni normalización) ----------------------
# Los árboles de decisión NO necesitan estandarización ni one-hot encoding.

receta_arbol <- recipe(experiencia_agrupada ~ ., data = datos_train) |>
  
  step_zv(all_predictors())

summary(receta_arbol)

# 4) Modelo de árbol de decisión ----------------------------------------------

# Hiperparámetros elegidos:
# - tree_depth = 20      -> profundidad máxima permitida
# - min_n = 100          -> hojas con mínimo de 100 observaciones (menos sobreajuste)
# - cost_complexity = 0.001 -> un poco de poda por complejidad

arbol_spec <- decision_tree(
  cost_complexity = 0.001,
  tree_depth      = 20,
  min_n           = 100
) |>
  set_engine("rpart") |>
  set_mode("classification")

arbol_spec

# 5) Workflow (receta + modelo) ----------------------------------------------

arbol_wf <- workflow() |>
  add_model(arbol_spec) |>
  add_recipe(receta_arbol)

# 6) Entrenamiento del modelo -------------------------------------------------

set.seed(123)
arbol_fit <- arbol_wf |>
  fit(data = datos_train)

cat("\nModelo entrenado.\n")

# 7) Evaluación en el conjunto de test ----------------------------------------

# Predicciones de clase en test
pred_test <- predict(arbol_fit, new_data = datos_test) |>
  bind_cols(datos_test |> select(experiencia_agrupada))

# Métricas básicas: accuracy, kappa, etc.
cat("\nMétricas en el conjunto de test:\n")
metricas_test <- pred_test |>
  metrics(truth = experiencia_agrupada, estimate = .pred_class)
print(metricas_test)

# Matriz de confusión
cat("\nMatriz de confusión en test:\n")
cm_test <- pred_test |>
  conf_mat(truth = experiencia_agrupada, estimate = .pred_class)
print(cm_test)

# 8) Probabilidades, ROC y AUC -----------------------------------------------

# Probabilidades de cada clase en test
pred_prob_test <- predict(arbol_fit, new_data = datos_test, type = "prob") |>
  bind_cols(datos_test |> select(experiencia_agrupada))

cat("\nColumnas de predicción de probabilidad:\n")
print(names(pred_prob_test))

# Identificamos las columnas de probabilidad (.pred_*)
prob_cols <- grep("^\\.pred_", names(pred_prob_test), value = TRUE)

# Mostramos qué columnas ha encontrado
cat("\nColumnas de probabilidad detectadas:\n")
print(prob_cols)

# Elegimos la segunda como clase positiva en este caso
# (prob_cols = c(".pred_Resto", ".pred_Buena_Muy_Buena"),
# la positiva será ".pred_Buena_Muy_Buena")
pos_col <- prob_cols[2]
cat("\nUsando como clase positiva la columna:", pos_col, "\n")

# Curva ROC
roc_obj <- roc_curve(
  pred_prob_test,
  truth = experiencia_agrupada,
  !!sym(pos_col)
)

autoplot(roc_obj)

# AUC
auc_val <- roc_auc(
  pred_prob_test,
  truth = experiencia_agrupada,
  !!sym(pos_col)
)

cat("\nAUC del árbol de decisión:\n")
print(auc_val)

# 9) Visualización del árbol --------------------------------------------------

cat("\nMostrando el árbol de decisión (estructura)...\n")

modelo_rpart <- arbol_fit |>
  extract_fit_engine()

rpart.plot(
  modelo_rpart,
  roundint    = FALSE,
  box.palette = "GnBu",
  yes.text    = "sí",
  no.text     = "no",
  tweak       = 1.2
)
```






  



```{r}
############################################################
# MODELO RANDOM FOREST PARA experiencia_agrupada
############################################################

# 1. Paquetes necesarios -----------------------------------

library(tidyverse)
library(caret)
library(randomForest)

############################################################
# 2. Carga de datos
############################################################


datos <- readr::read_csv("datos_finales.csv")

############################################################
# 3. Preprocesado
############################################################

# - Convertir la variable objetivo a factor
# - Eliminar CALIFICAR_EXPERIENCIA para evitar fuga de información
# - Pasar variables character y lógicas a factor

datos <- datos %>%
  mutate(
    experiencia_agrupada   = as.factor(experiencia_agrupada),
    # Eliminar variable casi equivalente al target
    CALIFICAR_EXPERIENCIA  = NULL,
    # Todas las character a factor
    across(where(is.character), as.factor),
    # Las lógicas también a factor (TRUE/FALSE -> niveles)
    across(where(is.logical), as.factor)
  )%>%
  drop_na() 

# Comprobar niveles de la variable objetivo
print(table(datos$experiencia_agrupada))

############################################################
# 4. Train / Test split estratificado
############################################################

set.seed(123)  # para reproducibilidad

# 80% entrenamiento, 20% test
idx_train <- createDataPartition(datos$experiencia_agrupada,
                                 p = 0.8,
                                 list = FALSE)

train <- datos[idx_train, ]
test  <- datos[-idx_train, ]

############################################################
# 5. Definición del control de entrenamiento (caret)
############################################################

ctrl <- trainControl(
  method = "cv",        # validación cruzada
  number = 5,           # 5 folds
  verboseIter = TRUE    # ver progreso
 
)

############################################################
# 6. Grid de hiperparámetros y entrenamiento Random Forest
############################################################

# mtry = nº de predictores muestreados en cada split

grid_rf <- expand.grid(
  mtry = c(3, 5, 7, 9)
)

set.seed(123)
modelo_rf <- train(
  experiencia_agrupada ~ .,
  data      = train,
  method    = "rf",
  trControl = ctrl,
  tuneGrid  = grid_rf,
  ntree     = 50,      # nº de árboles 
  importance = TRUE
)

# Resumen del modelo y del mejor mtry
print(modelo_rf)
print(modelo_rf$bestTune)

############################################################
# 7. Evaluación en el conjunto de test
############################################################

# Predicciones de clase
pred_clase <- predict(modelo_rf, newdata = test)

# Matriz de confusión y métricas (Accuracy, Kappa, etc.)
cm <- confusionMatrix(pred_clase, test$experiencia_agrupada)
print(cm)


pred_prob <- predict(modelo_rf, newdata = test, type = "prob")
head(pred_prob)

############################################################
# 8. Importancia de variables
############################################################

# Importancia de variables según el modelo RF
imp <- varImp(modelo_rf)
print(imp)

# Gráfico de las 20 variables más importantes
plot(imp, top = 20)
```



```{r}

```




```{r}
############################################################
# MODELO XGBOOST PARA experiencia_agrupada
############################################################

# Paquetes necesarios

library(caret)
library(xgboost)
library(dplyr)

############################################################
# 1. CARGA + PREPARACIÓN DEL DATASET
############################################################

datos <- datos_finales    # <-- usa tu data frame final

# ELIMINAMOS variable que contiene la respuesta original
datos$CALIFICAR_EXPERIENCIA <- NULL

# Definimos target con nombres simples
datos$experiencia_agrupada <- factor(
  datos$experiencia_agrupada,
  levels = c("Resto", "Buena/Muy Buena"),
  labels = c("Resto", "Buena")
)

############################################################
# 2. FEATURE ENGINEERING (variables nuevas)
############################################################

datos <- datos %>%
  mutate(
    GASTO_POR_NOCHE = ifelse(NOCHES > 0, GASTO_EUROS / NOCHES, NA_real_),
    RATIO_COSTE_VUELO_ALOJ = ifelse(COSTE_ALOJ_EUROS > 0,
                                    COSTE_VUELOS_EUROS / COSTE_ALOJ_EUROS,
                                    NA_real_)
  )

# Eliminamos filas con NA (muy pocos NA)
datos <- na.omit(datos)

############################################################
# 3. TRAIN / TEST SPLIT
############################################################

set.seed(123)

indice_train <- createDataPartition(
  datos$experiencia_agrupada,
  p = 0.7,
  list = FALSE
)

train <- datos[indice_train, ]
test  <- datos[-indice_train, ]

############################################################
# 4. ENTRENAMIENTO XGBOOST (con tuning)
############################################################

ctrl <- trainControl(
  method = "cv",
  number = 3,               # validación cruzada 3-fold
  classProbs = FALSE,
  summaryFunction = defaultSummary
)

grid_xgb <- expand.grid(
  nrounds = c(100, 200),
  max_depth = c(3, 6),
  eta = c(0.05, 0.1),
  gamma = 0,
  colsample_bytree = c(0.7, 1.0),
  min_child_weight = 1,
  subsample = c(0.7, 1.0)
)

set.seed(123)
modelo_xgb <- train(
  experiencia_agrupada ~ .,
  data = train,
  method = "xgbTree",
  trControl = ctrl,
  tuneGrid = grid_xgb,
  metric = "Accuracy"
)

print(modelo_xgb)
plot(modelo_xgb)

############################################################
# 5. EVALUACIÓN DEL MODELO EN TEST
############################################################

pred_xgb <- predict(modelo_xgb, newdata = test)

cm_xgb <- confusionMatrix(pred_xgb, test$experiencia_agrupada)
print(cm_xgb)

accuracy_xgb <- cm_xgb$overall["Accuracy"]
cat("ACCURACY FINAL:", accuracy_xgb, "\n")

############################################################
# 6. IMPORTANCIA DE VARIABLES
############################################################

imp_xgb <- varImp(modelo_xgb)
print(imp_xgb)

plot(imp_xgb, top = 20)   # top 20 variables más importantes
```

`
```{r}

```

